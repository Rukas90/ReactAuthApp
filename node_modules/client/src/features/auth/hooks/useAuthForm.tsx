import { VoidResult, Result } from "@project/shared"
import { useState } from "react"
import { z } from "zod"

interface UseAuthOptions<TSchema extends z.ZodSchema> {
  schema: TSchema
  onAuth: (
    data:
      | z.infer<TSchema>
      | {
          captchaToken: string
        }
  ) => Promise<VoidResult<string>>
  getValidationError: (
    form: FormData,
    validationError: z.ZodSafeParseError<z.infer<TSchema>>
  ) => string
}
const useAuthForm = <TSchema extends z.ZodSchema>({
  schema,
  onAuth,
  getValidationError,
}: UseAuthOptions<TSchema>) => {
  const [error, setError] = useState<string | null>(null)
  const [fieldErrors, setFieldErrors] = useState<Set<string>>(new Set())
  const [captchaToken, setCaptchaToken] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)

  const onSubmit = async (form: FormData) => {
    if (isLoading) {
      return
    }
    setIsLoading(true)

    try {
      const validation = await validate(form)

      if (!validation.ok) {
        setError(validation.error)
        return
      }
      var result = validation.data
      const auth = await onAuth({ ...result.data!, captchaToken })

      if (!auth.ok) {
        setError(auth.error)
      }
    } catch (error) {
      if (error instanceof Error) {
        setError(error.message)
      }
    } finally {
      setIsLoading(false)
    }
  }

  const validate = async (
    form: FormData
  ): Promise<Result<z.ZodSafeParseResult<z.core.output<TSchema>>, string>> => {
    const entries = Object.fromEntries(form)
    const result = await schema.safeParseAsync(entries)

    evaluateValidationResult(result)

    if (!result.success) {
      const errorMessage = getValidationError(form, result)
      return Result.error(errorMessage)
    }
    if (!captchaToken) {
      return Result.error("Please complete the Captcha.")
    }
    return Result.success(result)
  }

  const evaluateValidationResult = (
    result: z.ZodSafeParseResult<z.infer<TSchema>>
  ): Set<string> => {
    const newFieldErrors = new Set<string>()

    try {
      if (result.success) {
        return newFieldErrors
      }
      result.error.issues.forEach((issue) => {
        const fieldName = issue.path[0]

        if (fieldName && typeof fieldName === "string") {
          newFieldErrors.add(fieldName)
        }
      })
      setFieldErrors(newFieldErrors)
      return newFieldErrors
    } finally {
      setFieldErrors(newFieldErrors)
    }
  }
  return {
    error,
    fieldErrors,
    captchaToken,
    setCaptchaToken,
    onSubmit,
    isLoading,
  }
}

export default useAuthForm
